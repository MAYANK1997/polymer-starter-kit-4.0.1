import {
  Box,
  Button,
  Checkbox,
  Dialog,
  Field,
  HStack,
  Input,
  NativeSelect,
  Portal,
  Stack,
  Textarea,
  createToaster,
} from '@chakra-ui/react'
import { useForm } from 'react-hook-form'
import { useMutation, useQueryClient, useQuery } from '@tanstack/react-query'
import { useEffect, useState } from 'react'

interface CreateCategoryModalProps {
  isOpen: boolean
  onClose: () => void
  category?: any // For edit mode
  mode?: 'create' | 'edit'
}

interface CategoryFormData {
  restrictionCategoryName: string
  description: string
  fundGroup: string
  fundNames: string[]
  availableFor: string[]
}

// ------- Mock API helpers -------
const fetchFundNames = async (fundGroup: string) => {
  await new Promise((r) => setTimeout(r, 500))
  const fundNamesByGroup: Record<string, string[]> = {
    Volantis: ['1798 Volantis Catalyst', 'Volantis Growth Fund', 'Volantis Value Fund'],
    'LOIM IT': ['LOIM Technology Fund', 'LOIM Innovation Fund', 'LOIM Digital Fund'],
    'ESG Funds': ['ESG Global Fund', 'ESG Sustainable Fund', 'ESG Impact Fund'],
  }
  return fundNamesByGroup[fundGroup] || []
}

const fetchAvailableFor = async (fundGroup: string) => {
  await new Promise((r) => setTimeout(r, 500))
  const availableForByGroup: Record<string, string[]> = {
    Volantis: ['Developers', 'Portfolio Managers', 'Risk Managers'],
    'LOIM IT': ['LOAM IT', 'Portfolio Managers', 'System Administrators'],
    'ESG Funds': ['ESG Team', 'Compliance', 'Audit'],
  }
  return availableForByGroup[fundGroup] || []
}

// Create a toaster instance (v3)
const toaster = createToaster({ placement: 'top-right' })

export function CreateCategoryModal({
  isOpen,
  onClose,
  category,
  mode = 'create',
}: CreateCategoryModalProps) {
  const {
    register,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<CategoryFormData>({
    defaultValues: {
      restrictionCategoryName: '',
      description: '',
      fundGroup: '',
      fundNames: [],
      availableFor: [],
    },
  })

  const queryClient = useQueryClient()
  const [selectedFundGroup, setSelectedFundGroup] = useState('')

  const fundGroup = watch('fundGroup')
  const selectedFundNames = watch('fundNames') || []
  const selectedAvailableFor = watch('availableFor') || []

  // Dependent data
  const { data: fundNames = [] } = useQuery({
    queryKey: ['fund-names', fundGroup],
    queryFn: () => fetchFundNames(fundGroup),
    enabled: !!fundGroup,
  })

  const { data: availableForOptions = [] } = useQuery({
    queryKey: ['available-for', fundGroup],
    queryFn: () => fetchAvailableFor(fundGroup),
    enabled: !!fundGroup,
  })

  // Reset dependent fields when fund group changes
  useEffect(() => {
    if (fundGroup !== selectedFundGroup) {
      setValue('fundNames', [])
      setValue('availableFor', [])
      setSelectedFundGroup(fundGroup)
    }
  }, [fundGroup, selectedFundGroup, setValue])

  // Populate when editing
  useEffect(() => {
    if (mode === 'edit' && category && isOpen) {
      reset({
        restrictionCategoryName: category.restrictionCategoryName || '',
        description: category.description || '',
        fundGroup: category.fundGroup || '',
        fundNames: category.fundName ? category.fundName.split(', ') : [],
        availableFor: category.availableFor ? category.availableFor.split(', ') : [],
      })
      setSelectedFundGroup(category.fundGroup || '')
    } else if (mode === 'create' && isOpen) {
      reset({
        restrictionCategoryName: '',
        description: '',
        fundGroup: '',
        fundNames: [],
        availableFor: [],
      })
      setSelectedFundGroup('')
    }
  }, [mode, category, isOpen, reset])

  // Mutate (create/update)
  const createMutation = useMutation({
    mutationFn: async (data: CategoryFormData) => {
      await new Promise((r) => setTimeout(r, 1000))
      return {
        ...data,
        id: mode === 'edit' ? category?.id : Date.now().toString(),
        fundName: data.fundNames.join(', '),
        availableFor: data.availableFor.join(', '),
        lastModifiedBy: 'current_user',
        lastModifiedOn: new Date().toISOString().split('T')[0],
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['restriction-categories'] })
      toaster.create({
        type: 'success',
        title: mode === 'edit' ? 'Category Updated' : 'Category Created',
        description: `The restriction category has been ${
          mode === 'edit' ? 'updated' : 'created'
        } successfully.`,
        duration: 3000,
      })
      reset()
      onClose()
    },
    onError: () => {
      toaster.create({
        type: 'error',
        title: 'Error',
        description: `Failed to ${mode} restriction category.`,
        duration: 3000,
      })
    },
  })

  const onSubmit = (data: CategoryFormData) => {
    createMutation.mutate(data)
  }

  // Helpers for multi-select checkboxes
  const handleFundNameChange = (name: string, checked: boolean) => {
    const next = checked
      ? [...selectedFundNames, name]
      : selectedFundNames.filter((n) => n !== name)
    setValue('fundNames', next, { shouldDirty: true })
  }

  const handleAvailableForChange = (opt: string, checked: boolean) => {
    const next = checked
      ? [...selectedAvailableFor, opt]
      : selectedAvailableFor.filter((n) => n !== opt)
    setValue('availableFor', next, { shouldDirty: true })
  }

  return (
    <Dialog.Root
      open={isOpen}
      onOpenChange={(e) => {
        if (!e.open) onClose()
      }}
    >
      <Portal>
        <Dialog.Backdrop />
        <Dialog.Positioner>
          <Dialog.Content maxW="720px">
            <Dialog.Header>
              <Dialog.Title>
                {mode === 'edit' ? 'Edit Restriction Category' : 'Add New Restriction Category'}
              </Dialog.Title>
              <Dialog.CloseTrigger />
            </Dialog.Header>

            <form onSubmit={handleSubmit(onSubmit)}>
              <Dialog.Body>
                <Stack gap="4">
                  {/* Category Name */}
                  <Field.Root invalid={!!errors.restrictionCategoryName}>
                    <Field.Label>Category Name</Field.Label>
                    <Input
                      {...register('restrictionCategoryName', {
                        required: 'Category Name is required',
                      })}
                      placeholder="Restriction Category Name"
                    />
                    <Field.ErrorText>
                      {errors.restrictionCategoryName?.message}
                    </Field.ErrorText>
                  </Field.Root>

                  {/* Description */}
                  <Field.Root>
                    <Field.Label>Description</Field.Label>
                    <Textarea {...register('description')} placeholder="Description" />
                  </Field.Root>

                  {/* Fund Group (Native select) */}
                  <Field.Root>
                    <Field.Label>Fund Group</Field.Label>
                    <NativeSelect.Root>
                      <NativeSelect.Field
                        placeholder="Select fund group"
                        {...register('fundGroup')}
                      >
                        <option value="">Select fund group</option>
                        <option value="Volantis">Volantis</option>
                        <option value="LOIM IT">LOIM IT</option>
                        <option value="ESG Funds">ESG Funds</option>
                      </NativeSelect.Field>
                      <NativeSelect.Indicator />
                    </NativeSelect.Root>
                  </Field.Root>

                  {/* Dependent columns */}
                  {fundGroup && (
                    <HStack align="flex-start" gap="4">
                      {/* Fund Names */}
                      <Field.Root flex="1">
                        <Field.Label>Fund Names</Field.Label>
                        <Box
                          borderWidth="1px"
                          rounded="md"
                          p="3"
                          maxH="160px"
                          overflowY="auto"
                        >
                          <Stack gap="2">
                            {fundNames.length > 0 ? (
                              fundNames.map((name) => {
                                const checked = selectedFundNames.includes(name)
                                return (
                                  <Checkbox.Root
                                    key={name}
                                    checked={checked}
                                    onCheckedChange={({ checked }) =>
                                      handleFundNameChange(name, !!checked)
                                    }
                                  >
                                    <Checkbox.HiddenInput />
                                    <Checkbox.Control />
                                    <Checkbox.Label>{name}</Checkbox.Label>
                                  </Checkbox.Root>
                                )
                              })
                            ) : (
                              <Box color="fg.muted" fontSize="sm">
                                Loading...
                              </Box>
                            )}
                          </Stack>
                        </Box>
                      </Field.Root>

                      {/* Available For */}
                      <Field.Root flex="1">
                        <Field.Label>Available For</Field.Label>
                        <Box
                          borderWidth="1px"
                          rounded="md"
                          p="3"
                          maxH="160px"
                          overflowY="auto"
                        >
                          <Stack gap="2">
                            {availableForOptions.length > 0 ? (
                              availableForOptions.map((opt) => {
                                const checked = selectedAvailableFor.includes(opt)
                                return (
                                  <Checkbox.Root
                                    key={opt}
                                    checked={checked}
                                    onCheckedChange={({ checked }) =>
                                      handleAvailableForChange(opt, !!checked)
                                    }
                                  >
                                    <Checkbox.HiddenInput />
                                    <Checkbox.Control />
                                    <Checkbox.Label>{opt}</Checkbox.Label>
                                  </Checkbox.Root>
                                )
                              })
                            ) : (
                              <Box color="fg.muted" fontSize="sm">
                                Loading...
                              </Box>
                            )}
                          </Stack>
                        </Box>
                      </Field.Root>
                    </HStack>
                  )}
                </Stack>
              </Dialog.Body>

              <Dialog.Footer>
                <HStack justify="flex-end" gap="3" w="full">
                  <Button variant="outline" onClick={onClose}>
                    Cancel
                  </Button>
                  <Button
                    type="submit"
                    loading={createMutation.isPending}
                    colorPalette="blue"
                  >
                    {mode === 'edit' ? 'Update' : 'Create'}
                  </Button>
                </HStack>
              </Dialog.Footer>
            </form>
          </Dialog.Content>
        </Dialog.Positioner>
      </Portal>
    </Dialog.Root>
  )
}
