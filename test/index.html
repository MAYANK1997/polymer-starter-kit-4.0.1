import {
  Box,
  Button,
  Checkbox,
  Field,
  Fieldset,
  For,
  HStack,
  Input,
  NativeSelect,
  Spinner,
} from '@chakra-ui/react';
import { useForm } from 'react-hook-form';
import { useAsync } from 'react-use';
import { useMemo } from 'react';
import { config } from '@/config';
import { useMutation } from '@tanstack/react-query';

interface IssuerFormData {
  issuerName: string;
  issuerType: string;
  ticker: string;
  isin: string;
  cusip: string;
  sedol: string;
  instrumentType: string;
  categoryName: string; // string, sent to backend
  transactionTypes: string[]; // values: e.g. ["Buy","Sell"] or ["None"]
  dateRestricted: string;
  requester: string;
  notes: string;
}

interface RestrictionCategories {
  name: string;
}

const CreateIssuerModal = ({ onClose }: { onClose: () => void }) => {
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors },
  } = useForm<IssuerFormData>({
    defaultValues: {
      transactionTypes: ['None'], // default
      categoryName: '',
    },
  });

  // fetch categories
  const state = useAsync(async (): Promise<RestrictionCategories[]> => {
    const response = await fetch(`${config.apis.mdmApi}/EntitledRestrictionCategories`);
    if (!response.ok) return [];
    return response.json();
  }, []);

  // transaction types are synced with form via watch() and setValue()
  const transactionTypes = watch('transactionTypes') || ['None'];

  // handle checkbox toggle and keep form value in sync
  const handleTransactionToggle = (option: string) => {
    // compute next selection based on current form value
    const current = watch('transactionTypes') || ['None'];
    let next: string[];
    if (option === 'None') {
      next = ['None'];
    } else {
      const has = current.includes(option);
      if (has) {
        next = current.filter((v) => v !== option);
      } else {
        next = [...current.filter((v) => v !== 'None'), option];
      }
      if (next.length === 0) next = ['None'];
    }
    setValue('transactionTypes', next, { shouldDirty: true, shouldValidate: true });
  };

  // mutation to create issuer
  const mutation = useMutation({
    mutationFn: async (payload: IssuerFormData) => {
      const url = `${config.apis.mdmApi}/RestrictedIssuer`;
      const res = await fetch(url, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => '');
        throw new Error(`Failed to create issuer: ${res.status} ${txt}`);
      }
      return res.json();
    },
    onSuccess: () => {
      onClose();
    },
  });

  const onSubmit = (data: IssuerFormData) => {
    // ensure transactionTypes is taken from form (already synced)
    const payload = {
      ...data,
      transactionTypes: data.transactionTypes?.length ? data.transactionTypes : ['None'],
    };
    mutation.mutate(payload);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>Issuer Name</Field.Label>
          <Input
            {...register('issuerName', { required: 'Issuer name is required' })}
            placeholder="Enter value"
          />
        </Field.Root>

        <Field.Root>
          <Field.Label>Issuer Type</Field.Label>
          <NativeSelect.Root>
            <NativeSelect.Field {...register('issuerType')}>
              <option value="">Select type</option>
              <option value="Public">Public</option>
              <option value="Private">Private</option>
            </NativeSelect.Field>
            <NativeSelect.Indicator />
          </NativeSelect.Root>
        </Field.Root>
      </HStack>

      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>Ticker</Field.Label>
          <Input {...register('ticker')} placeholder="Enter value" />
        </Field.Root>
        <Field.Root>
          <Field.Label>ISIN</Field.Label>
          <Input {...register('isin')} placeholder="Enter value" />
        </Field.Root>
      </HStack>

      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>CUSIP</Field.Label>
          <Input {...register('cusip')} placeholder="Enter value" />
        </Field.Root>
        <Field.Root>
          <Field.Label>SEDOL</Field.Label>
          <Input {...register('sedol')} placeholder="Enter value" />
        </Field.Root>
      </HStack>

      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>Instrument Type</Field.Label>
          <NativeSelect.Root>
            <NativeSelect.Field {...register('instrumentType')}>
              <option value="">Select instrument</option>
              <option value="Equity">Equity</option>
              <option value="ADR">ADR</option>
              <option value="Index">Index</option>
              <option value="Govt">Govt</option>
              <option value="Corporate Bond">Corporate Bond</option>
              <option value="Convertible Bond">Convertible Bond</option>
            </NativeSelect.Field>
            <NativeSelect.Indicator />
          </NativeSelect.Root>
        </Field.Root>

        {/* ===== RESTRICTION CATEGORY (NativeSelect) =====
            Simpler and robust: bind to form directly using register.
         */}
        <Field.Root>
          <Field.Label>Restriction Category</Field.Label>
          <NativeSelect.Root>
            <NativeSelect.Field {...register('categoryName')}>
              <option value="">Select category</option>
              {state.value?.map((c) => (
                <option key={c.name} value={c.name}>
                  {c.name}
                </option>
              ))}
            </NativeSelect.Field>
            <NativeSelect.Indicator />
          </NativeSelect.Root>
        </Field.Root>
      </HStack>

      {/* Transaction types - synced with form state */}
      <HStack gap={4} mb={4}>
        <Fieldset.Root>
          <Fieldset.Legend>Allowed Transaction Type</Fieldset.Legend>
          <Box border="1px solid" borderColor="gray.600" borderRadius="md" p={3}>
            <Fieldset.Content>
              <For each={['Buy', 'Sell', 'Buy to Cover', 'Sell Short', 'None']}>
                {(value) => (
                  <Checkbox
                    key={value}
                    isChecked={transactionTypes.includes(value)}
                    onChange={() => handleTransactionToggle(value)}
                    value={value}
                    mr={3}
                  >
                    {value}
                  </Checkbox>
                )}
              </For>
            </Fieldset.Content>
          </Box>
        </Fieldset.Root>
      </HStack>

      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>Start Date</Field.Label>
          <Input {...register('dateRestricted')} type="date" defaultValue="2025-08-25" />
        </Field.Root>

        <Field.Root>
          <Field.Label>Restriction Requester</Field.Label>
          <Input {...register('requester')} placeholder="Enter value" />
        </Field.Root>
      </HStack>

      <HStack gap={4} mb={4}>
        <Field.Root>
          <Field.Label>Restriction Notes</Field.Label>
          <Input {...register('notes')} placeholder="Enter value" />
        </Field.Root>
      </HStack>

      <HStack justify="flex-end" mt={6}>
        <Button variant="outline" onClick={onClose}>
          Cancel
        </Button>

        {/* use mutation.isPending (TSQ v5) or mutation.isLoading (v4) as appropriate */}
        <Button type="submit" colorScheme="blue" isLoading={mutation.isPending ?? mutation.isLoading}>
          Save
        </Button>
      </HStack>
    </form>
  );
};

export default CreateIssuerModal;
