import { useCallback, useMemo, useRef, useState } from "react";
import { Box } from "@chakra-ui/react";
import { AgGridReact } from "ag-grid-react";
import {
  ClientSideRowModelModule,
  ColDef,
  ModuleRegistry,
  CellEditingStartedEvent,
  CellEditingStoppedEvent,
} from "ag-grid-community";
import { NewsletterRow } from "@/data/newsletterData";
import LinkRenderer from "./LinkRenderer";
import { useToast } from "@/hooks/use-toast";

ModuleRegistry.registerModules([ClientSideRowModelModule]);

interface NewsletterGridProps {
  data: NewsletterRow[];
  searchTerm: string;
  loading?: boolean;
}

const NewsletterGrid = ({
  data,
  searchTerm,
  loading = false,
}: NewsletterGridProps) => {
  const gridRef = useRef<AgGridReact>(null);
  const [editingRowId, setEditingRowId] = useState<number | null>(null);
  const { toast } = useToast();

  const highlightText = (text: string, search: string): string => {
    if (!search) return text;
    const regex = new RegExp(
      `(${search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`,
      "gi"
    );
    return text.replace(
      regex,
      '<mark class="bg-highlight text-highlight-foreground px-0.5 rounded">$1</mark>'
    );
  };

  const TextCellRenderer = useCallback(
    (params: { value: string }) => {
      const highlighted = highlightText(params.value || "", searchTerm);
      return <span dangerouslySetInnerHTML={{ __html: highlighted }} />;
    },
    [searchTerm]
  );

  const LinkCellRenderer = useCallback(
    (params: { value: string[] }) => (
      <LinkRenderer links={params.value || []} />
    ),
    []
  );

  const columnDefs = useMemo<ColDef[]>(
    () => [
      {
        headerName: "Date",
        field: "date",
        width: 120,
        cellRenderer: TextCellRenderer,
        sortable: true,
      },
      {
        headerName: "Section",
        field: "section",
        width: 160,
        cellRenderer: TextCellRenderer,
        sortable: true,
      },
      {
        headerName: "Strategy",
        field: "strategy",
        width: 130,
        cellRenderer: TextCellRenderer,
        sortable: true,
      },
      {
        headerName: "Person/Firm",
        field: "personFirm",
        width: 200,
        editable: true,
        cellRenderer: TextCellRenderer,
        sortable: true,
        cellClass: "cursor-pointer",
      },
      {
        headerName: "Location",
        field: "location",
        width: 160,
        editable: true,
        cellRenderer: TextCellRenderer,
        sortable: true,
        cellClass: "cursor-pointer",
      },
      {
        headerName: "Information",
        field: "information",
        flex: 1,
        minWidth: 300,
        editable: true,
        cellRenderer: TextCellRenderer,
        sortable: true,
        cellClass: "cursor-pointer",
        wrapText: true,
        autoHeight: true,
      },
      {
        headerName: "Link",
        field: "links",
        width: 200,
        cellRenderer: LinkCellRenderer,
        sortable: false,
      },
    ],
    [TextCellRenderer, LinkCellRenderer]
  );

  const defaultColDef = useMemo<ColDef>(
    () => ({
      resizable: true,
      filter: false,
    }),
    []
  );

  const onCellEditingStarted = useCallback(
    (event: CellEditingStartedEvent) => {
      setEditingRowId(event.data.id);
    },
    []
  );

  const onCellEditingStopped = useCallback(
    async (event: CellEditingStoppedEvent) => {
      if (event.data.id !== editingRowId) return;

      const row = event.data as NewsletterRow;

      try {
        await fetch("/api/newsletter/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(row),
        });

        toast({
          title: "Row Updated",
          description: `Successfully updated record for ${row.personFirm}`,
        });
      } catch {
        toast({
          title: "Update Failed",
          description: "Failed to save changes. Please try again.",
          variant: "destructive",
        });
      } finally {
        setEditingRowId(null);
      }
    },
    [editingRowId, toast]
  );

  const filteredData = useMemo(() => {
    if (!searchTerm) return data;

    const term = searchTerm.toLowerCase();
    return data.filter(
      (row) =>
        row.date.toLowerCase().includes(term) ||
        row.section.toLowerCase().includes(term) ||
        row.strategy.toLowerCase().includes(term) ||
        row.personFirm.toLowerCase().includes(term) ||
        row.location.toLowerCase().includes(term) ||
        row.information.toLowerCase().includes(term)
    );
  }, [data, searchTerm]);

  return (
    <Box
      className="ag-theme-quartz"
      w="full"
      h="calc(100vh - 200px)"
      border="1px solid"
      borderColor="border.default"
      borderRadius="lg"
      overflow="hidden"
      shadow="sm"
      opacity={loading ? 0.6 : 1}
      pointerEvents={loading ? "none" : "auto"}
    >
      <AgGridReact
        ref={gridRef}
        rowData={filteredData}
        columnDefs={columnDefs}
        defaultColDef={defaultColDef}
        animateRows
        rowSelection="single"
        stopEditingWhenCellsLoseFocus
        onCellEditingStarted={onCellEditingStarted}
        onCellEditingStopped={onCellEditingStopped}
        getRowId={(params) => params.data.id.toString()}
      />
    </Box>
  );
};

export default NewsletterGrid;
